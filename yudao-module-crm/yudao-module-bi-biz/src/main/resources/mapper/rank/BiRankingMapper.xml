<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="cn.iocoder.yudao.module.bi.dal.mysql.BiRankingMapper">


    <select id="contractRanKing"
            resultType="cn.iocoder.yudao.module.bi.controller.admin.ranking.vo.BiContractRanKingRespVO">
        SELECT IFNULL(SUM(t.price), 0) AS price, su.nickname, t.owner_user_id, dept.name AS deptName
        FROM crm_contract t
        <!-- TODO @anhaohao：system_users、system_dept 是不是没用到？尽量不连这 2 个表，微服务下会是独立仓库；如果显示需要，可以在 service 读取后拼接； -->
        LEFT JOIN system_users AS su ON su.id = t.owner_user_id
        LEFT JOIN system_dept AS dept ON dept.id = su.dept_id
        WHERE t.deleted = 0
        AND t.audit_status = 20
        <if test="userIds != null and userIds.size() > 0">
            and t.owner_user_id in
            <foreach collection="userIds" item="item" open="(" close=")" separator=",">
                #{item}
            </foreach>
        </if>
        <!-- TODO @anhaohao：在某个区间的时间，这么做有点浪费性能；一般做法是 beginTime 是开始时间（00:00:00），finalTime 是结束时间（23:59:59），这样实现的； -->
        AND DATE_FORMAT(t.order_date,'${sqlDateFormat}') between #{beginTime} and #{finalTime}
        GROUP BY t.owner_user_id
        ORDER BY price DESC
    </select>

    <select id="receivablesRanKing"
            resultType="cn.iocoder.yudao.module.bi.controller.admin.ranking.vo.BiReceivablesRanKingRespVO">
        SELECT IFNULL(SUM(t.price), 0) AS price, su.nickname, t.owner_user_id, dept.name AS deptName
        FROM crm_receivable t
        LEFT JOIN system_users AS su ON su.id = t.owner_user_id
        LEFT JOIN system_dept AS dept ON dept.id = su.dept_id
        WHERE t.deleted = 0
        AND t.audit_status = 20
        <if test="userIds != null and userIds.size() > 0">
            and t.owner_user_id in
            <foreach collection="userIds" item="item" open="(" close=")" separator=",">
                #{item}
            </foreach>
        </if>
        AND DATE_FORMAT(t.return_time,'${sqlDateFormat}') between #{beginTime} and #{finalTime}
        GROUP BY t.owner_user_id
        ORDER BY price DESC
    </select>
</mapper>
